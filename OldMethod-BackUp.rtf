{\rtf1\ansi\ansicpg1252\cocoartf2867
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 LSB:\
\
Consid\'e9rese una imagen de dimensiones $m \\times n$ con $c$ canales ($c \\in \\\{1,3\\\}$). El n\'famero total de muestras de 8 bits es $N = m n c$. Se reserva una cabecera de $32$ bits para codificar la longitud del mensaje (en bytes), de modo que la capacidad efectiva resulta\
\\[\
C_\{\\text\{efectiva\}\} = N - 32 \\ \\text\{bits\},\
\\]\
lo que equivale a una longitud m\'e1xima de mensaje de $\\big\\lfloor (N-32)/8 \\big\\rfloor$ bytes.\\\\\
\
El procedimiento de inserci\'f3n mediante LSB se formaliza como sigue. En primer lugar, se adquiere la imagen de cubierta (desde una ruta o como matriz en memoria) y se verifica que su representaci\'f3n sea \\texttt\{uint8\}. En segundo t\'e9rmino, el mensaje se codifica en un vector de bytes y se obtiene su longitud como un entero de 32 bits (\\texttt\{uint32\}). A continuaci\'f3n, se construye una cabecera de 32 bits que codifica dicha longitud en orden LSB-primero por byte, en consonancia con las rutinas auxiliares, y se concatena con el flujo de bits del mensaje. Acto seguido, se comprueba que la capacidad del portador sea suficiente para albergar la cabecera y los datos. Posteriormente, los bits resultantes se escriben secuencialmente en el bit menos significativo de los p\'edxeles mediante \\texttt\{bitset\}. Por \'faltimo, la imagen esteganogr\'e1fica se reconstituye con \\texttt\{reshape\}. La complejidad temporal del algoritmo es lineal en el n\'famero de bits insertados, esto es, $\\mathcal\{O\}(N)$, y el consumo adicional de memoria es marginal, limitado al \\textit\{bitstream\} temporal.\\\\\
\
\\begin\{lstlisting\}[language=Matlab]\
function stego = lsb_encode(coverImg, message)\
% Leer imagen si se entreg\'f3 ruta\
    if ischar(coverImg) || isstring(coverImg)\
        cover = imread(coverImg);\
    else\
        cover = coverImg;\
    end\
\
    if ~isa(cover,'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    % Convertir mensaje a bytes (UTF-8/ASCII)\
    msgBytes = uint8(message);\
    msgLen   = uint32(numel(msgBytes));      % longitud en bytes (32 bits)\
\
    % Empaquetar longitud (32 bits) y datos a un flujo de bits [0/1]\
    lenBytes = typecast(msgLen,'uint8');     % 4 bytes (endianness local)\
    bitsLen  = bytes2bits(lenBytes);\
    bitsMsg  = bytes2bits(msgBytes);\
    bitstream = [bitsLen; bitsMsg];          % columna de uint8\
\
    % Capacidad\
    pixels = cover(:);\
    capacity = numel(pixels);                % 1 bit por pixel\
    nbits = numel(bitstream);\
\
    if nbits > capacity\
        error('Capacidad insuficiente: se requieren %d bits y hay %d.', nbits, capacity);\
    end\
\
    % Escribir LSBs\
    pixels(1:nbits) = bitset(pixels(1:nbits), 1, bitstream);\
\
    % Reconstruir imagen\
    stego = reshape(pixels, size(cover));\
end\
\
% ------- Helpers --------\
function bits = bytes2bits(u8)\
% Convierte vector uint8 -> columna de bits (LSB primero por byte)\
    n = numel(u8);\
    bits = zeros(n*8,1,'uint8');\
    idx = 1;\
    for k = 1:n\
        b = u8(k);\
        for bit = 0:7\
            bits(idx) = bitget(b, bit+1);  % LSB primero\
            idx = idx + 1;\
        end\
    end\
end\
\\end\{lstlisting\}\
\
El procedimiento de extracci\'f3n invierte el algoritmo anterior. En primera instancia, se carga la imagen esteganogr\'e1fica y se linealizan sus p\'edxeles en un vector. Seguidamente, se recuperan los $32$ bits iniciales y se reagrupan en cuatro bytes para reconstruir la longitud del mensaje como un entero de 32 bits (\\texttt\{uint32\}). En tercer lugar, se calcula el n\'famero total de bits del mensaje, $B = 8\\,\\ell$ (donde $\\ell$ denota la longitud en bytes), y se verifica que el portador disponga de suficientes muestras para contenerlos. A continuaci\'f3n, se leen los siguientes $B$ bits desde los LSB de los p\'edxeles y se transforman en un vector de bytes. Finalmente, se reconstruye la cadena textual a partir de dichos bytes (por ejemplo, en \\textsc\{UTF-8\}).\\\\\
\
\\begin\{lstlisting\}[language=Matlab]\
function message = lsb_decode(stegoImg)\
    % Leer imagen si se entrego ruta\
    if ischar(stegoImg) || isstring(stegoImg)\
        stego = imread(stegoImg);\
    else\
        stego = stegoImg;\
    end\
\
    if ~isa(stego,'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    pixels = stego(:);\
\
    % Recuperar longitud (primeros 32 bits)\
    if numel(pixels) < 32\
        error('Imagen demasiado peque\'f1a para contener cabecera.');\
    end\
    lenBits = uint8(bitget(pixels(1:32),1));\
    lenBytes = bits2bytes(lenBits);\
    msgLen = typecast(uint8(lenBytes),'uint32');  % bytes de mensaje\
\
    % Recuperar mensaje\
    totalMsgBits = double(msgLen) * 8;\
    startIdx = 32 + 1;\
    endIdx   = 32 + totalMsgBits;\
\
    if endIdx > numel(pixels)\
        error('La imagen no contiene suficientes bits para el mensaje indicado.');\
    end\
\
    msgBits = uint8(bitget(pixels(startIdx:endIdx),1));\
    msgU8   = uint8(bits2bytes(msgBits));\
\
    % Convertir a texto (interpreta como UTF-8/ASCII)\
    message = char(msgU8(:)).';\
end\
\
% ------- Helpers --------\
function u8 = bits2bytes(bits)\
% Convierte columna de bits (LSB primero por byte) -> vector uint8\
    nbits = numel(bits);\
    if mod(nbits,8) ~= 0\
        error('El n\'famero de bits (%d) no es multiplo de 8.', nbits);\
    end\
    nbytes = nbits/8;\
    u8 = zeros(1,nbytes,'uint8');\
    idx = 1;\
    for k = 1:nbytes\
        val = uint8(0);\
        for bit = 0:7\
            if bits(idx) == 1\
                val = bitset(val, bit+1);\
            end\
            idx = idx + 1;\
        end\
        u8(k) = val;\
    end\
end\
\\end\{lstlisting\}\
\
\\begin\{lstlisting\}[language=Matlab]\
function stego = lsb_encode(coverImg, message)\
% Leer imagen si se entreg\'f3 ruta\
    if ischar(coverImg) || isstring(coverImg)\
        cover = imread(coverImg);\
    else\
        cover = coverImg;\
    end\
\
    if ~isa(cover,'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    % Convertir mensaje a bytes (UTF-8/ASCII)\
    msgBytes = uint8(message);\
    msgLen   = uint32(numel(msgBytes));      % longitud en bytes (32 bits)\
\
    % Empaquetar longitud (32 bits) y datos a un flujo de bits [0/1]\
    lenBytes = typecast(msgLen,'uint8');     % 4 bytes (endianness local)\
    bitsLen  = bytes2bits(lenBytes);\
    bitsMsg  = bytes2bits(msgBytes);\
    bitstream = [bitsLen; bitsMsg];          % columna de uint8\
\
    % Capacidad\
    pixels = cover(:);\
    capacity = numel(pixels);                % 1 bit por pixel\
    nbits = numel(bitstream);\
\
    if nbits > capacity\
        error('Capacidad insuficiente: se requieren %d bits y hay %d.', nbits, capacity);\
    end\
\
    % Escribir LSBs\
    pixels(1:nbits) = bitset(pixels(1:nbits), 1, bitstream);\
\
    % Reconstruir imagen\
    stego = reshape(pixels, size(cover));\
end\
\
% ------- Helpers --------\
function bits = bytes2bits(u8)\
% Convierte vector uint8 -> columna de bits (LSB primero por byte)\
    n = numel(u8);\
    bits = zeros(n*8,1,'uint8');\
    idx = 1;\
    for k = 1:n\
        b = u8(k);\
        for bit = 0:7\
            bits(idx) = bitget(b, bit+1);  % LSB primero\
            idx = idx + 1;\
        end\
    end\
end\
\\end\{lstlisting\}\
\
\\begin\{lstlisting\}[language=Matlab]\
function message = lsb_decode(stegoImg)\
    % Leer imagen si se entrego ruta\
    if ischar(stegoImg) || isstring(stegoImg)\
        stego = imread(stegoImg);\
    else\
        stego = stegoImg;\
    end\
\
    if ~isa(stego,'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    pixels = stego(:);\
\
    % Recuperar longitud (primeros 32 bits)\
    if numel(pixels) < 32\
        error('Imagen demasiado peque\'f1a para contener cabecera.');\
    end\
    lenBits = uint8(bitget(pixels(1:32),1));\
    lenBytes = bits2bytes(lenBits);\
    msgLen = typecast(uint8(lenBytes),'uint32');  % bytes de mensaje\
\
    % Recuperar mensaje\
    totalMsgBits = double(msgLen) * 8;\
    startIdx = 32 + 1;\
    endIdx   = 32 + totalMsgBits;\
\
    if endIdx > numel(pixels)\
        error('La imagen no contiene suficientes bits para el mensaje indicado.');\
    end\
\
    msgBits = uint8(bitget(pixels(startIdx:endIdx),1));\
    msgU8   = uint8(bits2bytes(msgBits));\
\
    % Convertir a texto (interpreta como UTF-8/ASCII)\
    message = char(msgU8(:)).';\
end\
\
% ------- Helpers --------\
function u8 = bits2bytes(bits)\
% Convierte columna de bits (LSB primero por byte) -> vector uint8\
    nbits = numel(bits);\
    if mod(nbits,8) ~= 0\
        error('El n\'famero de bits (%d) no es multiplo de 8.', nbits);\
    end\
    nbytes = nbits/8;\
    u8 = zeros(1,nbytes,'uint8');\
    idx = 1;\
    for k = 1:nbytes\
        val = uint8(0);\
        for bit = 0:7\
            if bits(idx) == 1\
                val = bitset(val, bit+1);\
            end\
            idx = idx + 1;\
        end\
        u8(k) = val;\
    end\
end\
\\end\{lstlisting\}\
\
\
\'97 \'97 \'97 \'97 \'97 \'97 \'97 \'97 \'97 \'97 \'97\
\
\
MSB:\
\
\\subsection\{Most Significant Bit (MSB)\}\
El m\'e9todo \\textit\{Most Significant Bit\} (MSB) consiste en ocultar informaci\'f3n forzando el bit m\'e1s significativo de cada p\'edxel (bit 8 en im\'e1genes \\texttt\{uint8\}). A diferencia de LSB, cada modificaci\'f3n sobre el MSB puede alterar la intensidad del p\'edxel hasta en $\\pm 128$ niveles, produciendo una distorsi\'f3n apreciable tal como se mostrar\'e1 en los resultados num\'e9ricos. En consecuencia, aunque la capacidad de inserci\'f3n es equivalente a LSB, la calidad visual se ve significativamente degradada.\
\
\\paragraph\{Capacidad y cabecera.\}\
Sea una imagen de dimensiones $m\\times n$ con $c$ canales ($c\\in\\\{1,3\\\}$). El n\'famero total de muestras es $N=mnc$. De forma an\'e1loga a LSB, se reservan los primeros $32$ bits para codificar la longitud del mensaje (en bytes), quedando\
\\[\
C_\{\\text\{efectiva\}\} = N - 32 \\ \\text\{bits\}, \
\\qquad \
|M|_\{\\max\} = \\Big\\lfloor \\frac\{N-32\}\{8\} \\Big\\rfloor \\ \\text\{bytes\}.\
\\]\
La cabecera se construye como \\texttt\{uint32\} y se transforma a 4 bytes mediante \\texttt\{typecast\}; posteriormente, cada byte se expande a bits en orden \\emph\{LSB-primero por byte\}, en coherencia con las funciones auxiliares. Respecto al \\emph\{endianness\}, la codificaci\'f3n y la decodificaci\'f3n con el mismo c\'f3digo garantizan consistencia; para intercambio entre plataformas heterog\'e9neas es recomendable fijar expl\'edcitamente \\emph\{little-endian\}.\
\
\\paragraph\{Impacto en la calidad.\}\
En MSB, la operaci\'f3n \\texttt\{bitset(.,8,.)\} impone el valor del bit 8 seg\'fan el flujo de inserci\'f3n, generando saltos de intensidad sustanciales. Ello repercute en una reducci\'f3n notable de la PSNR y un incremento del error (Frobenius, MSE). Este enfoque ilustra de manera directa c\'f3mo la posici\'f3n del bit determina la imperceptibilidad de la esteganograf\'eda.\
\
\\begin\{lstlisting\}[language=Matlab]\
function stego = msb_encode(coverImg, message)\
    % Leer imagen\
    if ischar(coverImg) || isstring(coverImg)\
        cover = imread(coverImg);\
    else\
        cover = coverImg;\
    end\
\
    if ~isa(cover, 'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    % Convertir mensaje a bytes y bits\
    msgBytes = uint8(message);\
    msgLen   = uint32(numel(msgBytes));  % longitud en bytes (32 bits)\
\
    lenBytes = typecast(msgLen, 'uint8');\
    bitsLen  = bytes2bits(lenBytes);\
    bitsMsg  = bytes2bits(msgBytes);\
    bitstream = [bitsLen; bitsMsg];      % concatenamos cabecera + datos\
\
    % Aplanar imagen\
    pixels = cover(:);\
    capacity = numel(pixels);\
    nbits = numel(bitstream);\
\
    if nbits > capacity\
        error('Capacidad insuficiente: %d bits requeridos, %d disponibles.', nbits, capacity);\
    end\
\
    % Escribir en el bit m\'e1s significativo\
    pixels(1:nbits) = bitset(pixels(1:nbits), 8, bitstream);\
\
    % Reconstruir imagen\
    stego = reshape(pixels, size(cover));\
end\
\
function bits = bytes2bits(u8)\
    n = numel(u8);\
    bits = zeros(n*8,1,'uint8');\
    idx = 1;\
    for k = 1:n\
        b = u8(k);\
        for bit = 0:7\
            bits(idx) = bitget(b, bit+1); % LSB
\f1 \uc0\u8594 
\f0 MSB\
            idx = idx + 1;\
        end\
    end\
end\
\\end\{lstlisting\}\
\
\\noindent\
\\textbf\{Extracci\'f3n.\} El proceso de decodificaci\'f3n invierte los pasos anteriores: primero se leen los $32$ bits iniciales desde el \\emph\{MSB\} de los p\'edxeles para reconstruir la longitud del mensaje (\\texttt\{uint32\}); a continuaci\'f3n, se consumen $8\\cdot |M|$ bits para recuperar los bytes del mensaje. Las consideraciones sobre \\emph\{endianness\} y codificaci\'f3n de caracteres son an\'e1logas a las del caso LSB (para acentos y emoji se recomienda \\texttt\{unicode2native\}/\\texttt\{native2unicode\}).\
\
\\begin\{lstlisting\}[language=Matlab]\
function message = msb_decode(stegoImg)\
    if ischar(stegoImg) || isstring(stegoImg)\
        stego = imread(stegoImg);\
    else\
        stego = stegoImg;\
    end\
\
    if ~isa(stego, 'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    pixels = stego(:);\
\
    % Leer longitud (primeros 32 bits)\
    lenBits = uint8(bitget(pixels(1:32), 8));\
    lenBytes = bits2bytes(lenBits);\
    msgLen = typecast(uint8(lenBytes), 'uint32');\
\
    % Leer mensaje\
    totalMsgBits = double(msgLen)*8;\
    startIdx = 33;\
    endIdx = 32 + totalMsgBits;\
\
    if endIdx > numel(pixels)\
        error('La imagen no contiene suficientes bits.');\
    end\
\
    msgBits = uint8(bitget(pixels(startIdx:endIdx), 8));\
    msgU8   = uint8(bits2bytes(msgBits));\
    message = char(msgU8(:)).';\
end\
\
function u8 = bits2bytes(bits)\
    nbits = numel(bits);\
    if mod(nbits,8) ~= 0\
        error('N\'famero de bits no m\'faltiplo de 8.');\
    end\
    nbytes = nbits/8;\
    u8 = zeros(1,nbytes,'uint8');\
    idx = 1;\
    for k = 1:nbytes\
        val = uint8(0);\
        for bit = 0:7\
            if bits(idx)\
                val = bitset(val, bit+1);\
            end\
            idx = idx + 1;\
        end\
        u8(k) = val;\
    end\
end\
\\end\{lstlisting\}\
\
\\begin\{lstlisting\}[language=Matlab]\
function stego = msb_encode(coverImg, message)\
    % Leer imagen\
    if ischar(coverImg) || isstring(coverImg)\
        cover = imread(coverImg);\
    else\
        cover = coverImg;\
    end\
\
    if ~isa(cover, 'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    % Convertir mensaje a bytes y bits\
    msgBytes = uint8(message);\
    msgLen   = uint32(numel(msgBytes));  % longitud en bytes (32 bits)\
\
    lenBytes = typecast(msgLen, 'uint8');\
    bitsLen  = bytes2bits(lenBytes);\
    bitsMsg  = bytes2bits(msgBytes);\
    bitstream = [bitsLen; bitsMsg];      % concatenamos cabecera + datos\
\
    % Aplanar imagen\
    pixels = cover(:);\
    capacity = numel(pixels);\
    nbits = numel(bitstream);\
\
    if nbits > capacity\
        error('Capacidad insuficiente: %d bits requeridos, %d disponibles.', nbits, capacity);\
    end\
\
    % Escribir en el bit m\'e1s significativo\
    pixels(1:nbits) = bitset(pixels(1:nbits), 8, bitstream);\
\
    % Reconstruir imagen\
    stego = reshape(pixels, size(cover));\
end\
\
function bits = bytes2bits(u8)\
    n = numel(u8);\
    bits = zeros(n*8,1,'uint8');\
    idx = 1;\
    for k = 1:n\
        b = u8(k);\
        for bit = 0:7\
            bits(idx) = bitget(b, bit+1); % LSB
\f1 \uc0\u8594 
\f0 MSB\
            idx = idx + 1;\
        end\
    end\
end\
\\end\{lstlisting\}\
\
\\begin\{lstlisting\}[language=Matlab]\
function message = msb_decode(stegoImg)\
    if ischar(stegoImg) || isstring(stegoImg)\
        stego = imread(stegoImg);\
    else\
        stego = stegoImg;\
    end\
\
    if ~isa(stego, 'uint8')\
        error('La imagen debe ser uint8 (8 bits por canal).');\
    end\
\
    pixels = stego(:);\
\
    % Leer longitud (primeros 32 bits)\
    lenBits = uint8(bitget(pixels(1:32), 8));\
    lenBytes = bits2bytes(lenBits);\
    msgLen = typecast(uint8(lenBytes), 'uint32');\
\
    % Leer mensaje\
    totalMsgBits = double(msgLen)*8;\
    startIdx = 33;\
    endIdx = 32 + totalMsgBits;\
\
    if endIdx > numel(pixels)\
        error('La imagen no contiene suficientes bits.');\
    end\
\
    msgBits = uint8(bitget(pixels(startIdx:endIdx), 8));\
    msgU8   = uint8(bits2bytes(msgBits));\
    message = char(msgU8(:)).';\
end\
\
function u8 = bits2bytes(bits)\
    nbits = numel(bits);\
    if mod(nbits,8) ~= 0\
        error('N\'famero de bits no m\'faltiplo de 8.');\
    end\
    nbytes = nbits/8;\
    u8 = zeros(1,nbytes,'uint8');\
    idx = 1;\
    for k = 1:nbytes\
        val = uint8(0);\
        for bit = 0:7\
            if bits(idx)\
                val = bitset(val, bit+1);\
            end\
            idx = idx + 1;\
        end\
        u8(k) = val;\
    end\
end\
\\end\{lstlisting\}\
\
\
MAIN_LSB:\
cover_path = '/home/yessica-trujillo/Documentos/Procesamiento-de-imagenes/Images/Ajedrez.png';\
outdir = fullfile(pwd, 'out');\
if ~exist(outdir, 'dir'), mkdir(outdir); end\
\
cover = imread(cover_path);\
\
%% Mensaje comun para todas las pruebas\
MSG = 'LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA';\
\
%% Caso A: LSB sin cifrado\
msg_A = MSG;\
\
stego_A = lsb_encode(cover, msg_A);\
file_A  = fullfile(outdir, 'stego_lsb_sin_cifrado.png');\
imwrite(stego_A, file_A, 'png');\
\
rec_A = lsb_decode(file_A);\
fprintf('Recuperado (sin cifrado): %s\\n', rec_A);\
\
[E_F_A, E_rel_A] = frobenius_error(cover, stego_A);\
\
%% Caso B: LSB + Cesar\
k = 3;                                \
msg_B_plain = MSG;                    \
msg_B_cif   = cesar_enc(msg_B_plain, k);   \
\
stego_B = lsb_encode(cover, msg_B_cif);    \
file_B  = fullfile(outdir, sprintf('stego_lsb_cesar_k%d.png', k));\
imwrite(stego_B, file_B, 'png');\
\
rec_B_cif = lsb_decode(file_B);            \
rec_B     = cesar_dec(rec_B_cif, k);       \
fprintf('Recuperado (Cesar k=%d): %s\\n', k, rec_B);\
\
[E_F_B, E_rel_B] = frobenius_error(cover, stego_B);\
\
%% Caso C: LSB + ElGamal (mod 257)\
p = 257;                          \
K = 123;                          \
msg_C_plain = MSG;                \
\
cbytes_C = elgamal_enc(msg_C_plain, K, p);           \
stego_C  = lsb_encode(cover, cbytes_C);              \
file_C   = fullfile(outdir, sprintf('stego_lsb_elgamal_p%d_K%d.png', p, K));\
imwrite(stego_C, file_C, 'png');\
\
rec_C_cif = uint8(lsb_decode(file_C));               \
rec_C     = elgamal_dec(rec_C_cif, K, p, true);       \
fprintf('Recuperado (ElGamal p=%d, K=%d): %s\\n', p, K, rec_C);\
\
[E_F_C, E_rel_C] = frobenius_error(cover, stego_C);  \
\
%% Caso D: LSB + Sustitucion monoalfabetica\
msg_D_plain = MSG;                         \
msg_D_cif   = sust_enc(msg_D_plain);       \
\
stego_D = lsb_encode(cover, msg_D_cif);    \
file_D  = fullfile(outdir, 'stego_lsb_sustitucion.png');\
imwrite(stego_D, file_D, 'png');\
\
rec_D_cif = lsb_decode(file_D);            \
rec_D     = sust_dec(rec_D_cif);           \
fprintf('Recuperado (Sustitucion): %s\\n', rec_D);\
\
[E_F_D, E_rel_D] = frobenius_error(cover, stego_D);  \
\
%% Caso E: LSB + Vigenere\
keyV = 'CLAVE';                             \
msg_E_plain = MSG;                         \
msg_E_cif   = vig_enc(msg_E_plain, keyV);  \
\
stego_E = lsb_encode(cover, msg_E_cif);    \
file_E  = fullfile(outdir, sprintf('stego_lsb_vigenere_key_%s.png', keyV));\
imwrite(stego_E, file_E, 'png');\
\
rec_E_cif = lsb_decode(file_E);            \
rec_E     = vig_dec(rec_E_cif, keyV);      \
fprintf('Recuperado (Vigenere key=%s): %s\\n', keyV, rec_E);\
\
[E_F_E, E_rel_E] = frobenius_error(cover, stego_E);  \
\
%% Tabla de errores (Frobenius absoluto y relativo)\
Metodo = [ ...\
    "LSB sin cifrado"; ...\
    sprintf("LSB + Cesar (k=%d)", k); ...\
    sprintf("LSB + ElGamal (p=%d, K=%d)", p, K); ...\
    "LSB + Sustitucion (monoalfabetica)"; ...\
    sprintf("LSB + Vigenere (key=%s)", keyV) ...\
];\
Error_F   = [E_F_A; E_F_B; E_F_C; E_F_D; E_F_E];\
Error_rel = [E_rel_A; E_rel_B; E_rel_C; E_rel_D; E_rel_E];\
\
T = table(Metodo, Error_F, Error_rel)\
\
\
MAIN_MSB:\
cover_path = '/home/yessica-trujillo/Documentos/Procesamiento-de-imagenes/Images/Ajedrez.png';\
outdir = fullfile(pwd, 'out');\
if ~exist(outdir, 'dir'), mkdir(outdir); end\
\
cover = imread(cover_path);\
\
%% Mensaje com\'fan para todas las pruebas\
MSG = 'LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA PARIATUR. EXCEPTEUR SINT OCCAECAT CUPIDATAT NON PROIDENT, SUNT IN CULPA QUI OFFICIA DESERUNT MOLLIT ANIM ID EST LABORUM. LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT, SED DO EIUSMOD TEMPOR INCIDIDUNT UT LABORE ET DOLORE MAGNA ALIQUA. UT ENIM AD MINIM VENIAM, QUIS NOSTRUD EXERCITATION ULLAMCO LABORIS NISI UT ALIQUIP EX EA COMMODO CONSEQUAT. DUIS AUTE IRURE DOLOR IN REPREHENDERIT IN VOLUPTATE VELIT ESSE CILLUM DOLORE EU FUGIAT NULLA';\
\
%% Caso A: MSB sin cifrado\
msg_A = MSG;\
\
stego_A = msb_encode(cover, msg_A);\
file_A  = fullfile(outdir, 'stego_msb_sin_cifrado.png');\
imwrite(stego_A, file_A, 'png');\
\
rec_A = msb_decode(file_A);\
fprintf('Recuperado (sin cifrado): %s\\n', rec_A);\
\
[E_F_A, E_rel_A] = frobenius_error(cover, stego_A);\
\
%% Caso B: MSB + C\'e9sar\
k = 3;                                \
msg_B_plain = MSG;                    \
msg_B_cif   = cesar_enc(msg_B_plain, k);   \
\
stego_B = msb_encode(cover, msg_B_cif);    \
file_B  = fullfile(outdir, sprintf('stego_msb_cesar_k%d.png', k));\
imwrite(stego_B, file_B, 'png');\
\
rec_B_cif = msb_decode(file_B);            \
rec_B     = cesar_dec(rec_B_cif, k);       \
fprintf('Recuperado (C\'e9sar k=%d): %s\\n', k, rec_B);\
\
[E_F_B, E_rel_B] = frobenius_error(cover, stego_B);\
\
%% Caso C: MSB + ElGamal (mod 257)\
p = 257;                          \
K = 123;                          \
msg_C_plain = MSG;                \
\
cbytes_C = elgamal_enc(msg_C_plain, K, p);           \
stego_C  = msb_encode(cover, cbytes_C);              \
file_C   = fullfile(outdir, sprintf('stego_msb_elgamal_p%d_K%d.png', p, K));\
imwrite(stego_C, file_C, 'png');\
\
rec_C_cif = uint8(msb_decode(file_C));               \
rec_C     = elgamal_dec(rec_C_cif, K, p, true);       \
fprintf('Recuperado (ElGamal p=%d, K=%d): %s\\n', p, K, rec_C);\
\
[E_F_C, E_rel_C] = frobenius_error(cover, stego_C);  \
\
%% Caso D: MSB + Sustituci\'f3n monoalfab\'e9tica\
msg_D_plain = MSG;                         \
msg_D_cif   = sust_enc(msg_D_plain);       \
\
stego_D = msb_encode(cover, msg_D_cif);    \
file_D  = fullfile(outdir, 'stego_msb_sustitucion.png');\
imwrite(stego_D, file_D, 'png');\
\
rec_D_cif = msb_decode(file_D);            \
rec_D     = sust_dec(rec_D_cif);           \
fprintf('Recuperado (Sustituci\'f3n): %s\\n', rec_D);\
\
[E_F_D, E_rel_D] = frobenius_error(cover, stego_D);  \
\
%% Caso E: MSB + Vigen\'e8re\
keyV = 'CLAVE';                             \
msg_E_plain = MSG;                         \
msg_E_cif   = vig_enc(msg_E_plain, keyV);  \
\
stego_E = msb_encode(cover, msg_E_cif);    \
file_E  = fullfile(outdir, sprintf('stego_msb_vigenere_key_%s.png', keyV));\
imwrite(stego_E, file_E, 'png');\
\
rec_E_cif = msb_decode(file_E);            \
rec_E     = vig_dec(rec_E_cif, keyV);      \
fprintf('Recuperado (Vigen\'e8re key=%s): %s\\n', keyV, rec_E);\
\
[E_F_E, E_rel_E] = frobenius_error(cover, stego_E);  \
\
%% Tabla de errores (Frobenius absoluto y relativo)\
Metodo = [ ...\
    "MSB sin cifrado"; ...\
    sprintf("MSB + C\'e9sar (k=%d)", k); ...\
    sprintf("MSB + ElGamal (p=%d, K=%d)", p, K); ...\
    "MSB + Sustituci\'f3n (monoalfab\'e9tica)"; ...\
    sprintf("MSB + Vigen\'e8re (key=%s)", keyV) ...\
];\
Error_F   = [E_F_A; E_F_B; E_F_C; E_F_D; E_F_E];\
Error_rel = [E_rel_A; E_rel_B; E_rel_C; E_rel_D; E_rel_E];\
\
T = table(Metodo, Error_F, Error_rel)}